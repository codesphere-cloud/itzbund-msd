webFrontend:
  image:
    pullPolicy: IfNotPresent
    repository: registry.opencode.de/bmi/ozg-rahmenarchitektur/ozgsec/ozgsec-web-frontend
    tag: v1.2.0@sha256:f7e0dbd798b9ef0dde808a38c4d482a9acdd7c0021466bccb8f685aecaf33c70
  # imagePullSecrets:
  # - name: regcred-oc-web-frontend
  annotations: {}
  podAnnotations: {}
  features:
    disableRefresh: false
    disableDashboard: false
  autoscaling:
    enabled: false
    # minReplicas: 2
    # maxReplicas: 100
    # targetCPUUtilizationPercentage: 80
  nodeSelector: {}
  tolerations: []
  affinity: {}
  replicaCount: 1
  ingress:
    enabled: true
    className: "traefik"
    # annotations:
    #   kubernetes.io/tls-acme: "true"
    #   cert-manager.io/cluster-issuer: letsencrypt-traefik
    hosts:
    - host: example.com
    tls:
    - secretName: tls-secret
      hosts:
      - example.com
  # specific application configuration
  config:
    # each domain gets scanned all 5 days
    scanInterval: "5"


bestPracticesScanner:
  image:
    repository: registry.opencode.de/bmi/ozg-rahmenarchitektur/ozgsec/ozgsec-best-practice-scanner
    pullPolicy: IfNotPresent
    tag: v1.1.0@sha256:57c36d576bc4ea898c45fadc9831bcd8361dd6f9b3490b6e9f96164024f5a8fb
  # imagePullSecrets:
  # - name: regcred-oc-best-practice-scanner
  autoscaling:
    enabled: false
    # minReplicas: 2
    # maxReplicas: 100
    # targetCPUUtilizationPercentage: 80
  nodeSelector: {}
  tolerations: []
  affinity: {}
  replicaCount: 2
  # specific application configuration
  config:
    # decrease this value to increase the performance of the scanner
    # but it will decrease the accuracy since some pages might need more time to load
    # defaults to 3000
    serverTimeout: "10000"
    # the amount of retries if a scanning request fails.
    # if the value is 0, the request wont be retried
    # defaults to 0
    serverRetries: "0"
    # the application communicates with ripe. If you are doing more than 1000 scans per day, you should
    # have a look right here: https://stat.ripe.net/docs/data_api (Rules of Usage)
    ripeSourceApp: ""
    rabbitMQConnectionRetries: 0
    enabledChecks:
    # # content checks
    # - subResourceIntegrity
    # - noMixedContent

    # # organizational checks
    - responsibleDisclosure

    # # dns checks
    - dnsSec
    # - caa

    # # networking
    - rpki
    # - ipv6


    # # http and configuration
    # - http
    # - http308
    # - httpRedirectsToHttps

    # # https
    # - https
    - hsts
    # - hstsPreloaded

    # # header checks
    # - contentSecurityPolicy
    # - xFrameOptions
    # - xssProtection
    # - contentTypeOptions
    # - secureSessionCookies

    # # encryption & certificate
    - tlsv1_3
    - tlsv1_2
    - deprecatedTLSDeactivated
    # - strongKeyExchange
    # - strongCipherSuites
    # - validCertificate
    # - strongPrivateKey
    # - strongSignatureAlgorithm
    # - matchesHostname
    # - notRevoked
    # - certificateTransparency
    # - validCertificateChain

    # # mail checks
    # - dkim
    # - dmarc
    # - spf
    # - starttls
    # - dane

    # # accessibility checks
    - providesEnglishWebsiteVersion


keycloak:
  image:
    repository: registry.opencode.de/bmi/ozg-rahmenarchitektur/ozgsec/ozgsec-keycloak
    pullPolicy: IfNotPresent
    tag: v1.0.0
  # imagePullSecrets:
  # - name: regcred-oc-keycloak
  nodeSelector: {}
  tolerations: []
  affinity: {}
  replicaCount: 1
  config:
    # this secret gets generated by the helm chart
    # (templates/keycloak/keycloak.secret.yaml)
    existingSecret:
      name: "keycloak"
      # checkov:skip=CKV_SECRET_6: False Positive
      dbPassKey: "DB_PASSWORD"
      adminUsernameKey: "ADMIN_USERNAME"
      adminPassKey: "ADMIN_PASS"
      keystorePassKey: "KEYSTORE_PASS"
  ingress:
    className: "traefik"
    enabled: true
    # annotations:
    #   kubernetes.io/tls-acme: "true"
    #   cert-manager.io/cluster-issuer: letsencrypt-traefik
    hosts:
    - host: auth.example.com
    tls:
    - secretName: auth-ozgsec-tls
      hosts:
      - auth.example.com

# postgresql database which is used by keycloak and the webFrontend
postgresql:
  architecture: standalone
  auth:
    # this secret gets generated by the helm chart
    # (templates/shared-secrets.yaml)
    # checkov:skip=CKV_SECRET_6: False Positive
    existingSecret: postgresql-credentials
    username: web-frontend
    database: web-frontend
    # will be overwritten by the existingSecret anyways.
    postgresPassword: "-"
    password: "-"
  primary:
    #extraEnvVarsSecret: "keycloak"
    #initdb:
    #  scripts:
    #    init_script.sh: |
    #      #!/bin/bash
    #      echo "Init Script: Creating database and user"
    #  
    #      export PGPASSWORD=$POSTGRES_POSTGRES_PASSWORD
    #
    #      psql -U postgres -c "CREATE DATABASE keycloak;" || { echo 'DB creation failed - skipping...'; }
    #      psql -U postgres -c "CREATE USER keycloak with password '$DB_PASSWORD';" || { echo 'USER creation failed - skipping...'; }
    #      psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE keycloak TO keycloak;" || { echo 'PRIVILEGES grant failed - skipping...'; }
    #      psql -U postgres -d keycloak -c "GRANT ALL PRIVILEGES ON SCHEMA public to keycloak;" || { echo 'SCHEMA PRIVILEGES grant failed - skipping...'; }
    persistence:
      enabled: true
      size: 120Gi
      # storageClass: "ceph-filesystem"
    resources:
      limits:
        cpu: "4"
        memory: "20Gi"
      requests:
        cpu: "0.5"
        memory: "6Gi"

# influxdb to monitor best practices scanner performance
influxdb:
  enabled: true
  auth:
    # this secret gets generated by the helm chart
    # (templates/shared-secrets.yaml)
    # checkov:skip=CKV_SECRET_6: False Positive
    existingSecret: influxdb-credentials
    writeUser:
      username: ozgsec-write
    readUser:
      username: ozgsec-read
    user:
      username: ozgsec
      org: ozgsec
      bucket: ozgsec
  ingress:
    enabled: false
    className: ""
    annotations: {}
    hosts:
    - host: monitoring.example.de
    tls:
    - secretName: monitoring-ozgsec-tls
      hosts:
      - monitoring.example.de
  influxdb:
    resources:
      limits: {}
      #cpu: "1"
      #memory: "2Gi"
      requests: {}
      #cpu: "0.0001"
      #memory: "1Gi"

# message queue between the best practices scanner and the webFrontend
rabbitmq:
  auth:
    username: ozgsec
    # this secret gets generated by the helm chart
    # (templates/shared-secrets.yaml)
    # checkov:skip=CKV_SECRET_6: False Positive
    existingPasswordSecret: rabbitmq-credentials
  resources:
    limits: {}
    #cpu: "1"
    #memory: "1Gi"
    requests: {}
    #cpu: "0.0001"
    #memory: "512Mi"


# cache for the best practices scanner
# we do not store any sensitive data in the cache
redis:
  architecture: standalone
  auth:
    enabled: false
  resources:
    limits: {}
    #cpu: "1"
    #memory: "1Gi"
    requests: {}
    #cpu: "0.0001"
    #memory: "512Mi"
